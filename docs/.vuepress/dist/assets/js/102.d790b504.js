(window.webpackJsonp=window.webpackJsonp||[]).push([[102],{507:function(t,u,e){"use strict";e.r(u);var r=e(2),p=Object(r.a)({},(function(){var t=this,u=t._self._c;return u("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[u("p",[t._v("OutputStream\n最后更新: 2019/8/13 07:26 / 阅读: 2266427\n和InputStream相反，OutputStream是Java标准库提供的最基本的输出流。")]),t._v(" "),u("p",[t._v("和InputStream类似，OutputStream也是抽象类，它是所有输出流的超类。这个抽象类定义的一个最重要的方法就是void write(int b)，签名如下：")]),t._v(" "),u("p",[t._v("public abstract void write(int b) throws IOException;\n这个方法会写入一个字节到输出流。要注意的是，虽然传入的是int参数，但只会写入一个字节，即只写入int最低8位表示字节的部分（相当于b & 0xff）。")]),t._v(" "),u("p",[t._v("和InputStream类似，OutputStream也提供了close()方法关闭输出流，以便释放系统资源。要特别注意：OutputStream还提供了一个flush()方法，它的目的是将缓冲区的内容真正输出到目的地。")]),t._v(" "),u("p",[t._v("为什么要有flush()？因为向磁盘、网络写入数据的时候，出于效率的考虑，操作系统并不是输出一个字节就立刻写入到文件或者发送到网络，而是把输出的字节先放到内存的一个缓冲区里（本质上就是一个byte[]数组），等到缓冲区写满了，再一次性写入文件或者网络。对于很多IO设备来说，一次写一个字节和一次写1000个字节，花费的时间几乎是完全一样的，所以OutputStream有个flush()方法，能强制把缓冲区内容输出。")]),t._v(" "),u("p",[t._v("通常情况下，我们不需要调用这个flush()方法，因为缓冲区写满了OutputStream会自动调用它，并且，在调用close()方法关闭OutputStream之前，也会自动调用flush()方法。")]),t._v(" "),u("p",[t._v("但是，在某些情况下，我们必须手动调用flush()方法。举个栗子：")]),t._v(" "),u("p",[t._v("小明正在开发一款在线聊天软件，当用户输入一句话后，就通过OutputStream的write()方法写入网络流。小明测试的时候发现，发送方输入后，接收方根本收不到任何信息，怎么肥四？")]),t._v(" "),u("p",[t._v("原因就在于写入网络流是先写入内存缓冲区，等缓冲区满了才会一次性发送到网络。如果缓冲区大小是4K，则发送方要敲几千个字符后，操作系统才会把缓冲区的内容发送出去，这个时候，接收方会一次性收到大量消息。")]),t._v(" "),u("p",[t._v("解决办法就是每输入一句话后，立刻调用flush()，不管当前缓冲区是否已满，强迫操作系统把缓冲区的内容立刻发送出去。")]),t._v(" "),u("p",[t._v("实际上，InputStream也有缓冲区。例如，从FileInputStream读取一个字节时，操作系统往往会一次性读取若干字节到缓冲区，并维护一个指针指向未读的缓冲区。然后，每次我们调用int read()读取下一个字节时，可以直接返回缓冲区的下一个字节，避免每次读一个字节都导致IO操作。当缓冲区全部读完后继续调用read()，则会触发操作系统的下一次读取并再次填满缓冲区。")]),t._v(" "),u("p",[t._v("FileOutputStream\n我们以FileOutputStream为例，演示如何将若干个字节写入文件流：")]),t._v(" "),u("p",[t._v('public void writeFile() throws IOException {\nOutputStream output = new FileOutputStream("out/readme.txt");\noutput.write(72); // H\noutput.write(101); // e\noutput.write(108); // l\noutput.write(108); // l\noutput.write(111); // o\noutput.close();\n}\n每次写入一个字节非常麻烦，更常见的方法是一次性写入若干字节。这时，可以用OutputStream提供的重载方法void write(byte[])来实现：')]),t._v(" "),u("p",[t._v('public void writeFile() throws IOException {\nOutputStream output = new FileOutputStream("out/readme.txt");\noutput.write("Hello".getBytes("UTF-8")); // Hello\noutput.close();\n}\n和InputStream一样，上述代码没有考虑到在发生异常的情况下如何正确地关闭资源。写入过程也会经常发生IO错误，例如，磁盘已满，无权限写入等等。我们需要用try(resource)来保证OutputStream在无论是否发生IO错误的时候都能够正确地关闭：')]),t._v(" "),u("p",[t._v('public void writeFile() throws IOException {\ntry (OutputStream output = new FileOutputStream("out/readme.txt")) {\noutput.write("Hello".getBytes("UTF-8")); // Hello\n} // 编译器在此自动为我们写入finally并调用close()\n}\n阻塞\n和InputStream一样，OutputStream的write()方法也是阻塞的。')]),t._v(" "),u("p",[t._v("OutputStream实现类\n用FileOutputStream可以从文件获取输出流，这是OutputStream常用的一个实现类。此外，ByteArrayOutputStream可以在内存中模拟一个OutputStream：")]),t._v(" "),u("p",[t._v('import java.io.*;\npublic class Main {\npublic static void main(String[] args) throws IOException {\nbyte[] data;\ntry (ByteArrayOutputStream output = new ByteArrayOutputStream()) {\noutput.write("Hello ".getBytes("UTF-8"));\noutput.write("world!".getBytes("UTF-8"));\ndata = output.toByteArray();\n}\nSystem.out.println(new String(data, "UTF-8"));\n}\n}')]),t._v(" "),u("p",[t._v("Run\nByteArrayOutputStream实际上是把一个byte[]数组在内存中变成一个OutputStream，虽然实际应用不多，但测试的时候，可以用它来构造一个OutputStream。")]),t._v(" "),u("p",[t._v("同时操作多个AutoCloseable资源时，在try(resource) { ... }语句中可以同时写出多个资源，用;隔开。例如，同时读写两个文件：")]),t._v(" "),u("p",[t._v('// 读取input.txt，写入output.txt:\ntry (InputStream input = new FileInputStream("input.txt");\nOutputStream output = new FileOutputStream("output.txt"))\n{\ninput.transferTo(output); // transferTo的作用是?\n}\n练习\n请利用InputStream和OutputStream，编写一个复制文件的程序，它可以带参数运行：')]),t._v(" "),u("p",[t._v("java CopyFile.java source.txt copy.txt\n从下载练习：CopyFile练习 （推荐使用IDE练习插件快速下载）")]),t._v(" "),u("p",[t._v("小结\nJava标准库的java.io.OutputStream定义了所有输出流的超类：")]),t._v(" "),u("p",[t._v("FileOutputStream实现了文件流输出；")]),t._v(" "),u("p",[t._v("ByteArrayOutputStream在内存中模拟一个字节流输出。")]),t._v(" "),u("p",[t._v("某些情况下需要手动调用OutputStream的flush()方法来强制输出缓冲区。")]),t._v(" "),u("p",[t._v("总是使用try(resource)来保证OutputStream正确关闭。")])])}),[],!1,null,null,null);u.default=p.exports}}]);